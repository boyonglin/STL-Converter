#pragma kernel CSMain

// Forward declarations
float3 GetOffsetRayDirection(float3 normal, float angleDegrees, int rayIndex);
float3 GetRadialDirection(float3 normal, float radAngle);
bool ProbeDirection(float3 worldPos, float3 rayDir, float eps, float maxU, out float errorMm, out float3 dispMm);
float4 MapBandColor(float valMm);
float3 SampleGradN(float3 pN);

// Buffers
StructuredBuffer<float3> vertexPositions;   // read-only
StructuredBuffer<float3> vertexNormals;     // read-only
RWStructuredBuffer<float4> vertexColors;
RWStructuredBuffer<float> errorResults;
RWStructuredBuffer<float3> errorVectors; // displacement vector from vertex to volume hit (mm)

// Volume data
Texture3D<float> volumeTexture;
SamplerState samplervolumeTexture; // Unity auto-binds sampler named 'sampler' + texture var name
Texture2D tfTexture; // optional transfer function for visibility parity
SamplerState samplertfTexture;

// Parameters
float4x4 worldToLocal;
float4x4 localToWorld;
float mmPerUnityUnit;
float surfaceEpsMm;
float maxProbeMm;
int tryBothDirections;
float densityThreshold; // 0..1 threshold to detect surface in volume
int useTransferFunction; // 1 = use tfTexture alpha and visibility window
float2 visibilityWindow; // min/max in normalised density
int3 volumeDims; // dataset dims for nearest-voxel sampling
int useNearestVoxel; // 1 = sample via nearest voxel value like CPU
int enableRefine; // 1 = refine surface intersection with bracketing/bisection

// Multi-directional sampling parameters
StructuredBuffer<float> rayAngleOffsets;
int rayAngleCount;
int enableMultiDirectional;
int useShortestDistance;

// Surface-specific parameters
int enableSurfaceSpecificRays;
StructuredBuffer<float> verticalAngles;
StructuredBuffer<float> horizontalAngles;
StructuredBuffer<float> obliqueAngles;
int verticalAngleCount;
int horizontalAngleCount;
int obliqueAngleCount;
float verticalThreshold;
float horizontalThreshold;

// Aggressive sampling
int enableAggressiveSampling;
int aggressiveRayCount;
float aggressiveMaxAngle;
int radialDirectionCount;

// Color mapping
StructuredBuffer<float> bandEdges;
StructuredBuffer<float4> bandColors;
int bandCount;
float colorMinMm;
float colorMaxMm;
int reverseColorScale;

// Advanced optimization
int enableErrorWeighting;
int useDistanceWeighting;
float maxWeightDistanceMm;
int enableOutlierFiltering;
float outlierThreshold;
int minValidSamples;
int vertexCount; // provided by C#

// Utility functions
float3 GetOffsetRayDirection(float3 normal, float angleDegrees, int rayIndex)
{
    if (abs(angleDegrees) < 0.001)
        return -normal;
    
    // Create orthogonal vectors
    float3 tangent1 = cross(normal, float3(0, 1, 0));
    if (length(tangent1) < 0.001)
        tangent1 = cross(normal, float3(0, 0, 1));
    tangent1 = normalize(tangent1);
    
    float3 tangent2 = normalize(cross(normal, tangent1));
    
    // Spiral sampling for better coverage
    float angleRad = angleDegrees * (3.14159/180.0);
    float spiralFactor = (angleDegrees / 90.0) * 3.14159 * 2 + rayIndex * 0.5;
    float3 rotationAxis = normalize(cos(spiralFactor) * tangent1 + sin(spiralFactor) * tangent2);
    
    // Rotate normal around axis
    float cosAngle = cos(angleRad);
    float sinAngle = sin(angleRad);
    float3 offsetNormal = normal * cosAngle + cross(rotationAxis, normal) * sinAngle + 
                         rotationAxis * dot(rotationAxis, normal) * (1 - cosAngle);
    
    return -normalize(offsetNormal);
}

float3 GetRadialDirection(float3 normal, float radAngle)
{
    float3 tangent1 = cross(normal, float3(0, 1, 0));
    if (length(tangent1) < 0.001)
        tangent1 = cross(normal, float3(1, 0, 0));
    tangent1 = normalize(tangent1);
    
    float3 tangent2 = normalize(cross(normal, tangent1));
    float3 radialDir = cos(radAngle) * tangent1 + sin(radAngle) * tangent2;
    
    return normalize(-normal * 0.7 + radialDir * 0.3);
}

bool IsVisible(float density)
{
    // visibility window (normalised)
    if (density < visibilityWindow.x || density > visibilityWindow.y)
        return false;
    if (useTransferFunction == 1)
    {
        float4 tfc = tfTexture.SampleLevel(samplertfTexture, float2(density, 0.5), 0);
        return tfc.a > 0.0;
    }
    else
    {
        return density > densityThreshold;
    }
}

// Central difference gradient in normalised texture coordinates [0,1]
float3 SampleGradN(float3 pN)
{
    float hx = 1.0 / max(1.0, float(volumeDims.x));
    float hy = 1.0 / max(1.0, float(volumeDims.y));
    float hz = 1.0 / max(1.0, float(volumeDims.z));

    float dx = volumeTexture.SampleLevel(samplervolumeTexture, float3(saturate(pN.x + hx), pN.y, pN.z), 0).r
            - volumeTexture.SampleLevel(samplervolumeTexture, float3(saturate(pN.x - hx), pN.y, pN.z), 0).r;
    float dy = volumeTexture.SampleLevel(samplervolumeTexture, float3(pN.x, saturate(pN.y + hy), pN.z), 0).r
            - volumeTexture.SampleLevel(samplervolumeTexture, float3(pN.x, saturate(pN.y - hy), pN.z), 0).r;
    float dz = volumeTexture.SampleLevel(samplervolumeTexture, float3(pN.x, pN.y, saturate(pN.z + hz)), 0).r
            - volumeTexture.SampleLevel(samplervolumeTexture, float3(pN.x, pN.y, saturate(pN.z - hz)), 0).r;
    return float3(dx, dy, dz) * 0.5;
}

bool ProbeDirection(float3 worldPos, float3 rayDir, float eps, float maxU, out float errorMm, out float3 dispMm)
{
    errorMm = 1e10;
    dispMm = float3(0,0,0);
    
    // Ray starting point (offset from surface)
    float3 rayStart = worldPos + rayDir * eps;
    float3 rayDirIn = -rayDir;
    
    // Step sizes
    const float stepLocal = 0.01; // CPU parity step in volume local units
    const float stepSizeCpu = stepLocal; // local units
    // Non-parity: ~0.25mm or 1% of range (world units)
    float stepSizeFast = min( (0.25 / mmPerUnityUnit), maxU * 0.01 );
    float stepSize = (useNearestVoxel == 1) ? stepSizeCpu : stepSizeFast;
    float maxDist = maxU; // world units
    
    // Find volume surface by marching along ray (forward direction)
    float3 volumeHitPoint = worldPos; // working value
    bool foundVolume = false;
    
    // Ensure start is outside the volume if possible (handle local/world coherently)
    float3 startPos = rayStart;
    float3 startLocalN = mul(worldToLocal, float4(startPos, 1)).xyz + 0.5; // [0,1]
    float startDensity = -1.0;
    if (startLocalN.x >= 0 && startLocalN.y >= 0 && startLocalN.z >= 0 &&
        startLocalN.x <= 1 && startLocalN.y <= 1 && startLocalN.z <= 1)
    {
        startDensity = volumeTexture.SampleLevel(samplervolumeTexture, startLocalN, 0).r;
    }
    if (IsVisible(startDensity))
    {
        [unroll]
        for (int k = 1; k <= 5; k++)
        {
            if (useNearestVoxel == 1)
            {
                float3 sLocal = mul(worldToLocal, float4(worldPos, 1)).xyz;
                float3 dLocal = normalize(mul(worldToLocal, float4(rayDir, 0)).xyz);
                float3 pL = sLocal + dLocal * (eps + stepLocal * k);
                float3 lpN = pL + 0.5;
                if (lpN.x >= 0 && lpN.y >= 0 && lpN.z >= 0 && lpN.x <= 1 && lpN.y <= 1 && lpN.z <= 1)
                {
                    float d = volumeTexture.SampleLevel(samplervolumeTexture, lpN, 0).r;
                    if (!IsVisible(d)) { startPos = mul(localToWorld, float4(pL, 1)).xyz; break; }
                }
                else { startPos = mul(localToWorld, float4(pL, 1)).xyz; break; }
            }
            else
            {
                float3 p = worldPos + rayDir * (eps + stepSize * k);
                float3 lp = mul(worldToLocal, float4(p, 1)).xyz + 0.5;
                if (lp.x >= 0 && lp.y >= 0 && lp.z >= 0 && lp.x <= 1 && lp.y <= 1 && lp.z <= 1)
                {
                    float d = volumeTexture.SampleLevel(samplervolumeTexture, lp, 0).r;
                    if (!IsVisible(d)) { startPos = p; break; }
                }
                else { startPos = p; break; }
            }
        }
    }

    float3 prevPos = startPos;
    float3 prevVolPos = mul(worldToLocal, float4(prevPos, 1)).xyz + 0.5;
    float prevD = -1.0;
    if (prevVolPos.x >= 0 && prevVolPos.y >= 0 && prevVolPos.z >= 0 &&
        prevVolPos.x <= 1 && prevVolPos.y <= 1 && prevVolPos.z <= 1)
        prevD = volumeTexture.SampleLevel(samplervolumeTexture, prevVolPos, 0).r;

    if (useNearestVoxel == 1)
    {
        // CPU parity: march in local space and stop at AABB exit or maxU
        float3 startLocal = mul(worldToLocal, float4(startPos, 1)).xyz;
        float3 dirLocal = normalize(mul(worldToLocal, float4(rayDirIn, 0)).xyz);
        float prevDLocal = -1.0;
        for (float tl = 0.0; tl <= 10000.0; tl += stepLocal)
        {
            float3 localPos = startLocal + dirLocal * tl;
            float3 volumePos = localPos + 0.5;
            // Stop if outside AABB
            if (!(volumePos.x >= 0 && volumePos.y >= 0 && volumePos.z >= 0 && volumePos.x <= 1 && volumePos.y <= 1 && volumePos.z <= 1))
                break;
            float3 samplePos = mul(localToWorld, float4(localPos, 1)).xyz;
            // Stop if exceeded max world distance
            if (length(samplePos - worldPos) > maxU)
                break;
            float density;
            int ix = clamp((int)round(volumePos.x * (volumeDims.x - 1)), 0, volumeDims.x - 1);
            int iy = clamp((int)round(volumePos.y * (volumeDims.y - 1)), 0, volumeDims.y - 1);
            int iz = clamp((int)round(volumePos.z * (volumeDims.z - 1)), 0, volumeDims.z - 1);
            float3 uvw = float3((ix + 0.5) / volumeDims.x, (iy + 0.5) / volumeDims.y, (iz + 0.5) / volumeDims.z);
            density = volumeTexture.SampleLevel(samplervolumeTexture, uvw, 0).r;
            if (prevDLocal < 0)
            {
                if (IsVisible(density)) { volumeHitPoint = samplePos; foundVolume = true; break; }
            }
            else
            {
                if (!IsVisible(prevDLocal) && IsVisible(density))
                {
                    // Use the current sample position as CPU would (first visible)
                    volumeHitPoint = samplePos;
                    foundVolume = true;
                    break;
                }
            }
            prevDLocal = density;
            prevPos = samplePos;
        }
    }
    else
    {
        for (float t = 0; t < maxDist; t += stepSize)
        {
            float3 samplePos = startPos + rayDirIn * t;
            
            // Transform to volume local space (centered at 0) then to [0..1]
            float3 volumePos = mul(worldToLocal, float4(samplePos, 1)).xyz + 0.5;
            
            // Check if inside volume bounds (explicit to help IDEs)
            if (volumePos.x >= 0 && volumePos.y >= 0 && volumePos.z >= 0 &&
                volumePos.x <= 1 && volumePos.y <= 1 && volumePos.z <= 1)
            {
                float density = volumeTexture.SampleLevel(samplervolumeTexture, volumePos, 0).r;
                // Handle first-inside-visible or crossing from not visible to visible
                if (prevD < 0)
                {
                    if (IsVisible(density))
                    {
                        volumeHitPoint = samplePos;
                        foundVolume = true;
                        break;
                    }
                }
                else if (!IsVisible(prevD) && IsVisible(density))
                {
                    // Linear interpolate along the segment for sub-step precision
                    float thr = densityThreshold;
                    float denom = max(1e-6, density - prevD);
                    float alpha = saturate((thr - prevD) / denom);
                    volumeHitPoint = lerp(prevPos, samplePos, alpha);
                    foundVolume = true;
                    break;
                }
                prevD = density;
                prevPos = samplePos;
            }
        }
    }
    
    // Capture forward-direction result
    bool foundA = foundVolume;
    float3 hitA = volumeHitPoint;
    
    // Also probe reverse direction if enabled
    if (tryBothDirections)
    {
        // Try reverse direction
        rayStart = worldPos - rayDir * eps;
        rayDirIn = rayDir;

        // Ensure start outside for reverse too
        startPos = rayStart;
        float3 startLocalN2 = mul(worldToLocal, float4(startPos, 1)).xyz + 0.5;
        startDensity = -1.0;
        if (startLocalN2.x >= 0 && startLocalN2.y >= 0 && startLocalN2.z >= 0 &&
            startLocalN2.x <= 1 && startLocalN2.y <= 1 && startLocalN2.z <= 1)
        {
            startDensity = volumeTexture.SampleLevel(samplervolumeTexture, startLocalN2, 0).r;
        }
        if (IsVisible(startDensity))
        {
            [unroll]
            for (int k = 1; k <= 5; k++)
            {
                if (useNearestVoxel == 1)
                {
                    float3 sLocal = mul(worldToLocal, float4(worldPos, 1)).xyz;
                    float3 dLocal = normalize(mul(worldToLocal, float4(-rayDir, 0)).xyz);
                    float3 pL = sLocal + dLocal * (eps + stepLocal * k);
                    float3 lpN = pL + 0.5;
                    if (lpN.x >= 0 && lpN.y >= 0 && lpN.z >= 0 && lpN.x <= 1 && lpN.y <= 1 && lpN.z <= 1)
                    {
                        float d = volumeTexture.SampleLevel(samplervolumeTexture, lpN, 0).r;
                        if (!IsVisible(d)) { startPos = mul(localToWorld, float4(pL, 1)).xyz; break; }
                    }
                    else { startPos = mul(localToWorld, float4(pL, 1)).xyz; break; }
                }
                else
                {
                    float3 p = worldPos - rayDir * (eps + stepSize * k);
                    float3 lp = mul(worldToLocal, float4(p, 1)).xyz + 0.5;
                    if (lp.x >= 0 && lp.y >= 0 && lp.z >= 0 && lp.x <= 1 && lp.y <= 1 && lp.z <= 1)
                    {
                        float d = volumeTexture.SampleLevel(samplervolumeTexture, lp, 0).r;
                        if (!IsVisible(d)) { startPos = p; break; }
                    }
                    else { startPos = p; break; }
                }
            }
        }
        prevPos = startPos;
        prevVolPos = mul(worldToLocal, float4(prevPos, 1)).xyz + 0.5;
        prevD = -1.0;
        if (prevVolPos.x >= 0 && prevVolPos.y >= 0 && prevVolPos.z >= 0 &&
            prevVolPos.x <= 1 && prevVolPos.y <= 1 && prevVolPos.z <= 1)
            prevD = volumeTexture.SampleLevel(samplervolumeTexture, prevVolPos, 0).r;

        if (useNearestVoxel == 1)
        {
            float3 startLocal = mul(worldToLocal, float4(startPos, 1)).xyz;
            float3 dirLocal = normalize(mul(worldToLocal, float4(rayDirIn, 0)).xyz);
            float prevDLocal2 = -1.0;
            for (float tl = 0.0; tl <= 10000.0; tl += stepLocal)
            {
                float3 localPos = startLocal + dirLocal * tl;
                float3 volumePos = localPos + 0.5;
                if (!(volumePos.x >= 0 && volumePos.y >= 0 && volumePos.z >= 0 && volumePos.x <= 1 && volumePos.y <= 1 && volumePos.z <= 1))
                    break;
                float3 samplePos = mul(localToWorld, float4(localPos, 1)).xyz;
                if (length(samplePos - worldPos) > maxU)
                    break;
                int ix = clamp((int)round(volumePos.x * (volumeDims.x - 1)), 0, volumeDims.x - 1);
                int iy = clamp((int)round(volumePos.y * (volumeDims.y - 1)), 0, volumeDims.y - 1);
                int iz = clamp((int)round(volumePos.z * (volumeDims.z - 1)), 0, volumeDims.z - 1);
                float3 uvw = float3((ix + 0.5) / volumeDims.x, (iy + 0.5) / volumeDims.y, (iz + 0.5) / volumeDims.z);
                float density = volumeTexture.SampleLevel(samplervolumeTexture, uvw, 0).r;
                if (prevDLocal2 < 0)
                {
                    if (IsVisible(density)) { volumeHitPoint = samplePos; foundVolume = true; break; }
                }
                else if (!IsVisible(prevDLocal2) && IsVisible(density))
                {
                    volumeHitPoint = samplePos;
                    foundVolume = true;
                    break;
                }
                prevDLocal2 = density;
                prevPos = samplePos;
            }
        }
        else
        {
            for (float t = 0; t < maxDist; t += stepSize)
            {
                float3 samplePos = startPos + rayDirIn * t;
                float3 volumePos = mul(worldToLocal, float4(samplePos, 1)).xyz + 0.5;
                
                if (volumePos.x >= 0 && volumePos.y >= 0 && volumePos.z >= 0 &&
                    volumePos.x <= 1 && volumePos.y <= 1 && volumePos.z <= 1)
                {
                    float density = volumeTexture.SampleLevel(samplervolumeTexture, volumePos, 0).r;
                    // First-inside-visible or crossing from not visible to visible
                    if (prevD < 0)
                    {
                        if (IsVisible(density))
                        {
                            volumeHitPoint = samplePos;
                            foundVolume = true;
                            break;
                        }
                    }
                    else if (!IsVisible(prevD) && IsVisible(density))
                    {
                        float thr = densityThreshold;
                        float denom = max(1e-6, density - prevD);
                        float alpha = saturate((thr - prevD) / denom);
                        volumeHitPoint = lerp(prevPos, samplePos, alpha);
                        foundVolume = true;
                        break;
                    }
                    prevD = density;
                    prevPos = samplePos;
                }
            }
        }
    }
    
    // Decide between forward and reverse results
    bool foundB = foundVolume;
    float3 hitB = volumeHitPoint;
    bool foundAny = foundA || foundB;
    if (!foundAny)
        return false;
    
    if (foundA && foundB)
    {
        float da = length(hitA - worldPos);
        float db = length(hitB - worldPos);
        volumeHitPoint = (da <= db) ? hitA : hitB;
    }
    else
    {
        volumeHitPoint = foundA ? hitA : hitB;
    }

    // Optional refinement by bracketing IsVisible crossing and bisection
    if (enableRefine == 1)
    {
        float3 dirToHit = normalize(volumeHitPoint - worldPos);
        float hi = length(volumeHitPoint - worldPos);
        float3 hiPos = volumeHitPoint;
        float3 hiLocal = mul(worldToLocal, float4(hiPos, 1)).xyz + 0.5;
        bool hiVis = false;
        if (hiLocal.x >= 0 && hiLocal.y >= 0 && hiLocal.z >= 0 && hiLocal.x <= 1 && hiLocal.y <= 1 && hiLocal.z <= 1)
        {
            float d = volumeTexture.SampleLevel(samplervolumeTexture, hiLocal, 0).r;
            hiVis = IsVisible(d);
        }
        float stepRefine = max( (0.1 / mmPerUnityUnit), hi * 0.05 );
        float lo = max(0.0, hi - stepRefine);
        float3 loPos = worldPos + dirToHit * lo;
        bool bracketed = false;
        [unroll]
        for (int s = 0; s < 6; s++)
        {
            lo = max(0.0, hi - (s+1) * stepRefine);
            loPos = worldPos + dirToHit * lo;
            float3 loLocal = mul(worldToLocal, float4(loPos, 1)).xyz + 0.5;
            bool loVis = false;
            if (loLocal.x >= 0 && loLocal.y >= 0 && loLocal.z >= 0 && loLocal.x <= 1 && loLocal.y <= 1 && loLocal.z <= 1)
            {
                float d = volumeTexture.SampleLevel(samplervolumeTexture, loLocal, 0).r;
                loVis = IsVisible(d);
            }
            if (loVis != hiVis)
            {
                bracketed = true;
                break;
            }
        }
        if (bracketed)
        {
            [unroll]
            for (int it = 0; it < 5; it++)
            {
                float mid = 0.5 * (lo + hi);
                float3 midPos = worldPos + dirToHit * mid;
                float3 midLocal = mul(worldToLocal, float4(midPos, 1)).xyz + 0.5;
                bool midVis = false;
                if (midLocal.x >= 0 && midLocal.y >= 0 && midLocal.z >= 0 && midLocal.x <= 1 && midLocal.y <= 1 && midLocal.z <= 1)
                {
                    float d = volumeTexture.SampleLevel(samplervolumeTexture, midLocal, 0).r;
                    midVis = IsVisible(d);
                }
                if (midVis == hiVis) { hi = mid; hiPos = midPos; }
                else { lo = mid; loPos = midPos; }
            }
            volumeHitPoint = hiPos;
        }
    }

    float3 diff = (volumeHitPoint - worldPos);
    errorMm = length(diff) * mmPerUnityUnit;
    dispMm = diff * mmPerUnityUnit;
    return true;
}

float4 MapBandColor(float valMm)
{
    // Clamp to color range
    float v = clamp(valMm, min(colorMinMm, colorMaxMm), max(colorMinMm, colorMaxMm));
    
    // Find appropriate band
    int idx = 0;
    // edges count = bandCount - 1 (C# ensures effective bandCount matches edges+1)
    int ec = max(1, bandCount - 1);
    for (int i = 0; i < ec; i++)
    {
        if (v <= bandEdges[i])
            break;
        idx++;
    }
    
    // Apply color reversal if enabled
    if (reverseColorScale)
        idx = (bandCount - 1) - idx;
    
    idx = clamp(idx, 0, bandCount - 1);
    return bandColors[idx];
}

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint vertexIndex = id.x;
    if (vertexIndex >= (uint)vertexCount)
        return;
        
    float3 vertexPos = vertexPositions[vertexIndex];
    float3 normal = normalize(vertexNormals[vertexIndex]);
    
    // Convert to Unity units
    float eps = surfaceEpsMm / mmPerUnityUnit;
    float maxU = maxProbeMm / mmPerUnityUnit;
    
    // Multi-ray sampling for accuracy
    float bestErrorMm = 1e10;
    float4 bestColor = float4(0.5, 0.5, 0.5, 1);
    bool foundHit = false;
    float3 bestRay = -normal; // default
    float3 bestVecMm = float3(0,0,0);
    
    // Store all ray results for intelligent weighting
    float rayErrors[32]; // Max 32 rays
    float rayWeights[32];
    int validRayCount = 0;
    
    // Surface type classification
    float verticalDot = abs(dot(normal, float3(0, 1, 0)));
    int surfaceType = 2; // 0=vertical, 1=horizontal, 2=oblique
    if (verticalDot > verticalThreshold)
        surfaceType = 0;
    else if (verticalDot < horizontalThreshold)
        surfaceType = 1;
    
    // Determine ray angles based on surface type
    int angleCount = enableMultiDirectional != 0 ? rayAngleCount : 1;
    if (enableSurfaceSpecificRays)
    {
        if (surfaceType == 0) angleCount = max(1, verticalAngleCount);
        else if (surfaceType == 1) angleCount = max(1, horizontalAngleCount);
        else angleCount = max(1, obliqueAngleCount);
    }
    
    // Main ray sampling loop
    [loop]
    for (int i = 0; i < min(angleCount, 32); i++)
    {
        float angle = 0;
        if (enableSurfaceSpecificRays)
        {
            if (surfaceType == 0 && i < verticalAngleCount)
                angle = verticalAngles[i];
            else if (surfaceType == 1 && i < horizontalAngleCount)
                angle = horizontalAngles[i];
            else if (surfaceType == 2 && i < obliqueAngleCount)
                angle = obliqueAngles[i];
        }
        else if (i < rayAngleCount)
        {
            angle = rayAngleOffsets[i];
        }
        
        // Generate ray direction with offset
        float3 rayDir = GetOffsetRayDirection(normal, angle, i);
        
        // Probe in this direction
        float errorMm;
        float3 dispMm;
        if (ProbeDirection(vertexPos, rayDir, eps, maxU, errorMm, dispMm))
        {
            if (validRayCount < 32)
            {
                rayErrors[validRayCount] = errorMm;
                
                // Calculate weight for this ray
                float weight = 1.0;
                if (enableErrorWeighting)
                {
                    // Distance weight
                    if (useDistanceWeighting)
                        weight *= exp(-errorMm / maxWeightDistanceMm);
                    // Angle weight (0 degree has the highest weight)
                    weight *= exp(-abs(angle) / 90.0);
                    // Accuracy weight
                    weight *= 1.0 / (1.0 + errorMm);
                }

                // Gradient-alignment weighting to down-weight likely wrong-layer hits
                float3 hitPos = vertexPos + (dispMm / mmPerUnityUnit);
                float3 pN = mul(worldToLocal, float4(hitPos, 1)).xyz + 0.5;
                float3 g = SampleGradN(pN);
                float gLen = length(g);
                float3 rayIn = normalize(-rayDir);
                float align = (gLen > 1e-6) ? abs(dot(normalize(g), rayIn)) : 0.0;
                weight *= (0.6 + 0.4 * saturate(align));
                
                rayWeights[validRayCount] = weight;
                validRayCount++;
            }
            
            foundHit = true;
            
            if (useShortestDistance && errorMm < bestErrorMm)
            {
                bestErrorMm = errorMm;
                bestRay = rayDir;
                bestVecMm = dispMm;
            }
        }
    }
    
    // Aggressive sampling for complex geometry
    if (enableAggressiveSampling && foundHit && validRayCount > 0)
    {
        // Add radial sampling
        [loop]
        for (int r = 0; r < min(radialDirectionCount, 16); r++)
        {
            if (validRayCount >= 32) break;
            
            float radAngle = (r * 2.0 * 3.14159) / radialDirectionCount;
            float3 radialDir = GetRadialDirection(normal, radAngle);
            
            float errorMm;
            float3 dispMm;
            if (ProbeDirection(vertexPos, radialDir, eps, maxU, errorMm, dispMm))
            {
                rayErrors[validRayCount] = errorMm;
                // Base weight for aggressive samples
                float weightR = 0.5;
                // Gradient alignment penalty to reduce wrong-layer picks
                float3 hitPosR = vertexPos + (dispMm / mmPerUnityUnit);
                float3 pNR = mul(worldToLocal, float4(hitPosR, 1)).xyz + 0.5;
                float3 gR = SampleGradN(pNR);
                float gLenR = length(gR);
                float3 rayInR = normalize(-radialDir);
                float alignR = (gLenR > 1e-6) ? abs(dot(normalize(gR), rayInR)) : 0.0;
                weightR *= (0.6 + 0.4 * saturate(alignR));
                rayWeights[validRayCount] = weightR;
                validRayCount++;
                if (useShortestDistance && errorMm < bestErrorMm) { bestErrorMm = errorMm; bestRay = radialDir; bestVecMm = dispMm; }
            }
        }
    }
    
    // Process results with outlier filtering and weighting
    if (validRayCount > 0)
    {
        // Outlier filtering
        if (enableOutlierFiltering && validRayCount >= minValidSamples)
        {
            // Calculate mean and std dev
            float mean = 0;
            for (int i = 0; i < validRayCount; i++)
                mean += rayErrors[i];
            mean /= validRayCount;
            
            float variance = 0;
            for (int j = 0; j < validRayCount; j++)
            {
                float diff = rayErrors[j] - mean;
                variance += diff * diff;
            }
            float stdDev = sqrt(variance / validRayCount);
            
            // Filter outliers
            int filteredCount = 0;
            for (int k = 0; k < validRayCount; k++)
            {
                if (abs(rayErrors[k] - mean) <= outlierThreshold * stdDev)
                {
                    rayErrors[filteredCount] = rayErrors[k];
                    rayWeights[filteredCount] = rayWeights[k];
                    filteredCount++;
                }
            }
            
            if (filteredCount >= minValidSamples)
                validRayCount = filteredCount;
        }
        
        // Weighted average or best result
        if (enableErrorWeighting && validRayCount > 1)
        {
            float totalWeight = 0;
            float weightedError = 0;
            
            for (int i = 0; i < validRayCount; i++)
            {
                totalWeight += rayWeights[i];
                weightedError += rayErrors[i] * rayWeights[i];
            }
            
            if (totalWeight > 0.001)
                bestErrorMm = weightedError / totalWeight;
            else
                bestErrorMm = rayErrors[0]; // Fallback to first result
        }
        else if (useShortestDistance)
        {
            // Find minimum error
            bestErrorMm = rayErrors[0];
            bestRay = normal; // will be overwritten below
            for (int i = 1; i < validRayCount; i++)
            {
                if (rayErrors[i] < bestErrorMm)
                    bestErrorMm = rayErrors[i];
            }
        }
        else
        {
            bestErrorMm = rayErrors[0]; // Use first valid result
        }
        
        // Map to color
        bestColor = MapBandColor(bestErrorMm);
    }
    
    // Store results
    errorResults[vertexIndex] = foundHit ? bestErrorMm : -1.0;
    errorVectors[vertexIndex] = foundHit ? bestVecMm : float3(0,0,0);
    vertexColors[vertexIndex] = bestColor;
}
